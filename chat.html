<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0f">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü§ù</text></svg>">
<title>HuddleClaw</title>
<link rel="manifest" href="data:application/json,{%22name%22:%22HuddleClaw%22,%22short_name%22:%22HuddleClaw%22,%22start_url%22:%22chat.html%22,%22display%22:%22standalone%22,%22background_color%22:%22%230a0a0f%22,%22theme_color%22:%22%230a0a0f%22}">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,400;9..40,500;9..40,600;9..40,700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0f; --bg2: #0e0e15; --surface: #141420; --surface2: #1a1a28;
  --surface3: #222233; --border: #2a2a3d; --border2: #353550;
  --text: #eaeaf0; --text2: #9898ad; --muted: #5e5e75;
  --accent: #6c5ce7; --accent2: #a29bfe; --accent-dim: rgba(108,92,231,0.12);
  --accent-glow: rgba(108,92,231,0.25);
  --green: #00cec9; --green-dim: rgba(0,206,201,0.1);
  --red: #ff6b6b; --red-dim: rgba(255,107,107,0.1);
  --orange: #ffa94d; --orange-dim: rgba(255,169,77,0.1);
  --blue: #74b9ff; --blue-dim: rgba(116,185,255,0.1);
  --sidebar-w: 280px;
  --r: 10px; --r-sm: 6px; --r-lg: 14px;
  --safe-top: env(safe-area-inset-top, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
}
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html { height:100%; overflow:hidden; }
body { font-family:'DM Sans',system-ui,sans-serif; background:var(--bg); color:var(--text); height:100%; overflow:hidden; }
::-webkit-scrollbar { width:5px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:var(--border); border-radius:3px; }
::selection { background:var(--accent-dim); }
input,button,textarea { font-family:inherit; }
a { color:var(--accent2); }

/* ‚ïê‚ïê‚ïê App Shell ‚ïê‚ïê‚ïê */
.app { display:flex; height:100%; position:relative; }

/* ‚ïê‚ïê‚ïê Sidebar ‚ïê‚ïê‚ïê */
.sidebar {
  width:var(--sidebar-w); background:var(--bg2); border-right:1px solid var(--border);
  display:flex; flex-direction:column; flex-shrink:0;
  padding-top:var(--safe-top);
  transition: transform .25s cubic-bezier(.4,0,.2,1);
  z-index:100;
}
.sidebar-header {
  padding:20px 16px 16px; display:flex; align-items:center; gap:10px;
}
.sidebar-header .logo {
  font-family:'IBM Plex Mono',monospace; font-size:14px; font-weight:700;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  -webkit-background-clip:text; -webkit-text-fill-color:transparent;
  letter-spacing:-0.5px;
}
.sidebar-header .dot {
  width:8px; height:8px; border-radius:50%; background:var(--green);
  box-shadow:0 0 8px var(--green); transition:all .3s;
}
.sidebar-header .dot.off { background:var(--red); box-shadow:0 0 8px var(--red); }
.sidebar-header .dot.connecting { background:var(--orange); box-shadow:0 0 8px var(--orange); animation:blink 1s infinite; }
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:.3} }

.sidebar-nav { flex:1; overflow-y:auto; padding:4px 0; }

.nav-group { padding:0 10px; margin-bottom:2px; }
.nav-group-title {
  font-size:10px; font-weight:700; text-transform:uppercase; letter-spacing:1.5px;
  color:var(--muted); padding:12px 8px 6px; user-select:none;
}
.nav-item {
  display:flex; align-items:center; gap:10px; padding:8px 10px; margin:1px 0;
  border-radius:var(--r-sm); cursor:pointer; transition:all .12s;
  font-size:14px; color:var(--text2); position:relative;
}
.nav-item:hover { background:var(--surface); color:var(--text); }
.nav-item.active { background:var(--accent-dim); color:var(--text); }
.nav-item .ni-icon { width:20px; text-align:center; font-size:15px; flex-shrink:0; }
.nav-item .ni-label { flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-weight:500; }
.nav-item .ni-dot {
  width:7px; height:7px; border-radius:50%; flex-shrink:0;
}
.nav-item .ni-dot.online { background:var(--green); }
.nav-item .ni-dot.busy { background:var(--orange); animation:blink 1s infinite; }
.nav-item .ni-badge {
  font-size:10px; font-weight:700; padding:1px 6px; border-radius:10px;
  background:var(--accent); color:#fff; min-width:18px; text-align:center;
}

.sidebar-footer {
  padding:12px 16px; border-top:1px solid var(--border);
  padding-bottom:max(12px, var(--safe-bottom));
}
.gateway-info {
  font-size:11px; color:var(--muted); display:flex; align-items:center; gap:6px;
  cursor:pointer; padding:6px 8px; border-radius:var(--r-sm); transition:all .15s;
}
.gateway-info:hover { background:var(--surface); color:var(--text2); }
.gateway-info .gi-url { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-family:'IBM Plex Mono',monospace; }

/* ‚ïê‚ïê‚ïê Main ‚ïê‚ïê‚ïê */
.main { flex:1; display:flex; flex-direction:column; min-width:0; }

.chat-header {
  padding:14px 20px; border-bottom:1px solid var(--border);
  display:flex; align-items:center; gap:12px; flex-shrink:0;
  background:var(--bg); min-height:56px;
  padding-top:max(14px, var(--safe-top));
}
.chat-header .ch-back {
  display:none; width:32px; height:32px; border:none; background:none;
  color:var(--text2); font-size:18px; cursor:pointer; border-radius:var(--r-sm);
}
.chat-header .ch-back:hover { background:var(--surface); color:var(--text); }
.chat-header .ch-emoji { font-size:20px; }
.chat-header .ch-info { flex:1; min-width:0; }
.chat-header .ch-name { font-size:15px; font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.chat-header .ch-sub { font-size:11px; color:var(--muted); margin-top:1px; }
.chat-header .ch-action {
  width:34px; height:34px; border-radius:var(--r-sm); border:1px solid var(--border);
  background:none; color:var(--text2); cursor:pointer; font-size:16px;
  display:flex; align-items:center; justify-content:center; transition:all .15s;
}
.chat-header .ch-action:hover { border-color:var(--accent); color:var(--accent); background:var(--accent-dim); }

/* Messages */
.messages { flex:1; overflow-y:auto; padding:16px 20px; display:flex; flex-direction:column; }
.messages .spacer { flex:1; }

.msg {
  display:flex; gap:10px; padding:6px 0; margin:2px 0;
  animation:msgIn .2s ease;
}
@keyframes msgIn { from{opacity:0;transform:translateY(6px)} to{opacity:1;transform:translateY(0)} }
.msg .m-avatar {
  width:36px; height:36px; border-radius:var(--r); flex-shrink:0;
  display:flex; align-items:center; justify-content:center; font-size:18px;
  background:var(--surface2); margin-top:2px;
}
.msg .m-body { flex:1; min-width:0; }
.msg .m-head { display:flex; align-items:baseline; gap:8px; margin-bottom:3px; }
.msg .m-name { font-size:13px; font-weight:700; }
.msg .m-time { font-size:10px; color:var(--muted); font-family:'IBM Plex Mono',monospace; }
.msg .m-text { font-size:14px; line-height:1.55; color:var(--text); word-break:break-word; }
.msg .m-text code { font-family:'IBM Plex Mono',monospace; font-size:12px; background:var(--surface2); padding:1px 5px; border-radius:4px; }
.msg .m-text pre { background:var(--surface); border:1px solid var(--border); border-radius:var(--r-sm); padding:10px 12px; margin:8px 0; overflow-x:auto; font-size:12px; line-height:1.5; }
.msg .m-text pre code { background:none; padding:0; }
.msg .m-text strong { color:var(--accent2); font-weight:600; }
.msg .m-text a { color:var(--accent2); text-decoration:none; }
.msg .m-text a:hover { text-decoration:underline; }
.msg .m-text ul, .msg .m-text ol { padding-left:20px; margin:4px 0; }
.msg .m-text li { margin:2px 0; }
.msg .m-text blockquote { border-left:3px solid var(--accent); padding-left:12px; color:var(--text2); margin:8px 0; }
.msg .m-text h1,.msg .m-text h2,.msg .m-text h3 { color:var(--accent2); margin:12px 0 4px; font-size:15px; }

.msg-system {
  text-align:center; padding:8px 0; font-size:12px; color:var(--muted);
}

.typing-indicator {
  padding:4px 20px; font-size:12px; color:var(--accent2); min-height:20px;
  font-style:italic;
}

/* Chat Input */
.input-area {
  padding:12px 16px; border-top:1px solid var(--border); background:var(--bg);
  padding-bottom:max(12px, var(--safe-bottom));
}
.input-wrap {
  display:flex; align-items:flex-end; gap:8px;
  background:var(--surface); border:1px solid var(--border); border-radius:var(--r-lg);
  padding:4px 4px 4px 16px; transition:border-color .15s;
}
.input-wrap:focus-within { border-color:var(--accent); box-shadow:0 0 0 2px var(--accent-glow); }
.input-wrap textarea {
  flex:1; border:none; background:none; color:var(--text); font-size:14px;
  resize:none; outline:none; max-height:120px; padding:8px 0; line-height:1.4;
}
.input-wrap textarea::placeholder { color:var(--muted); }
.send-btn {
  width:36px; height:36px; border-radius:var(--r); border:none;
  background:var(--accent); color:#fff; font-size:16px; font-weight:700;
  cursor:pointer; display:flex; align-items:center; justify-content:center;
  transition:all .15s; flex-shrink:0;
}
.send-btn:hover { background:var(--accent2); transform:scale(1.05); }
.send-btn:active { transform:scale(0.95); }
.send-btn:disabled { opacity:.3; cursor:default; transform:none; }

/* ‚ïê‚ïê‚ïê Connect Screen ‚ïê‚ïê‚ïê */
.connect-screen {
  display:flex; align-items:center; justify-content:center; height:100%;
  background:var(--bg); padding:20px;
}
.connect-card {
  width:100%; max-width:400px; text-align:center;
}
.connect-card .cc-logo { font-size:48px; margin-bottom:16px; }
.connect-card h1 {
  font-family:'IBM Plex Mono',monospace; font-size:24px; font-weight:700;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  -webkit-background-clip:text; -webkit-text-fill-color:transparent;
  margin-bottom:8px;
}
.connect-card .cc-sub { font-size:14px; color:var(--text2); margin-bottom:32px; line-height:1.5; }
.connect-card .cc-field {
  text-align:left; margin-bottom:16px;
}
.connect-card .cc-field label {
  display:block; font-size:11px; font-weight:700; text-transform:uppercase;
  letter-spacing:1px; color:var(--muted); margin-bottom:6px;
}
.connect-card .cc-field input {
  width:100%; padding:12px 14px; border:1px solid var(--border); border-radius:var(--r);
  background:var(--surface); color:var(--text); font-size:14px; outline:none;
  font-family:'IBM Plex Mono',monospace; transition:border-color .15s;
}
.connect-card .cc-field input:focus { border-color:var(--accent); box-shadow:0 0 0 2px var(--accent-glow); }
.connect-card .cc-field input::placeholder { color:var(--muted); }
.connect-btn {
  width:100%; padding:14px; border:none; border-radius:var(--r);
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  color:#fff; font-size:15px; font-weight:700; cursor:pointer;
  transition:all .15s; margin-top:8px;
}
.connect-btn:hover { transform:translateY(-1px); box-shadow:0 4px 20px var(--accent-glow); }
.connect-btn:active { transform:translateY(0); }
.connect-btn:disabled { opacity:.5; cursor:default; transform:none; box-shadow:none; }
.cc-error { color:var(--red); font-size:12px; margin-top:12px; min-height:18px; }
.cc-hint { font-size:11px; color:var(--muted); margin-top:20px; line-height:1.5; }
.cc-hint code { font-family:'IBM Plex Mono',monospace; background:var(--surface); padding:1px 5px; border-radius:3px; font-size:10px; }

/* ‚ïê‚ïê‚ïê Mobile ‚ïê‚ïê‚ïê */
@media (max-width: 768px) {
  .sidebar {
    position:fixed; top:0; left:0; bottom:0; width:85vw; max-width:320px;
    transform:translateX(-100%);
    box-shadow:4px 0 30px rgba(0,0,0,.5);
  }
  .sidebar.open { transform:translateX(0); }
  .sidebar-backdrop {
    display:none; position:fixed; inset:0; background:rgba(0,0,0,.5);
    z-index:99; backdrop-filter:blur(2px);
  }
  .sidebar-backdrop.show { display:block; }
  .chat-header .ch-back { display:flex; }
  .messages { padding:12px 14px; }
  .input-area { padding:8px 10px; }
}

/* ‚ïê‚ïê‚ïê Empty state ‚ïê‚ïê‚ïê */
.empty-state {
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  flex:1; text-align:center; padding:40px 20px; color:var(--muted);
}
.empty-state .es-emoji { font-size:48px; margin-bottom:16px; opacity:.6; }
.empty-state .es-title { font-size:16px; font-weight:600; color:var(--text2); margin-bottom:8px; }
.empty-state .es-sub { font-size:13px; line-height:1.5; max-width:300px; }
</style>
</head>
<body>

<!-- Connect Screen -->
<div class="connect-screen" id="connectScreen">
  <div class="connect-card">
    <div class="cc-logo">ü§ù</div>
    <h1>HuddleClaw</h1>
    <div class="cc-sub">Chat with your AI agents from anywhere.<br>Connect your OpenClaw gateway to get started.</div>
    <div class="cc-field">
      <label>Gateway URL</label>
      <input type="url" id="gwUrl" placeholder="http://localhost:18789" autocomplete="url" spellcheck="false">
    </div>
    <div class="cc-field">
      <label>Token</label>
      <input type="password" id="gwToken" placeholder="Your gateway token" autocomplete="current-password">
    </div>
    <button class="connect-btn" id="connectBtn" onclick="doConnect()">Connect ‚Üí</button>
    <div class="cc-error" id="connectError"></div>
    <div class="cc-hint">
      Run <code>openclaw gateway</code> on your machine, then connect here.<br>
      Find your token in <code>~/.openclaw/config.yaml</code>
    </div>
  </div>
</div>

<!-- Chat App -->
<div class="app" id="chatApp" style="display:none">
  <div class="sidebar-backdrop" id="backdrop" onclick="closeSidebar()"></div>
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <span class="dot" id="statusDot"></span>
      <span class="logo">HUDDLECLAW</span>
    </div>
    <div class="sidebar-nav" id="sidebarNav"></div>
    <div class="sidebar-footer">
      <div class="gateway-info" onclick="disconnect()">
        <span>üîå</span>
        <span class="gi-url" id="footerUrl"></span>
        <span style="font-size:10px">‚úï</span>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="chat-header" id="chatHeader">
      <button class="ch-back" onclick="openSidebar()">‚ò∞</button>
      <span class="ch-emoji" id="headerEmoji">#</span>
      <div class="ch-info">
        <div class="ch-name" id="headerName">general</div>
        <div class="ch-sub" id="headerSub"></div>
      </div>
    </div>

    <div class="messages" id="messages">
      <div class="empty-state">
        <div class="es-emoji">üí¨</div>
        <div class="es-title">Select a conversation</div>
        <div class="es-sub">Pick an agent from the sidebar to start chatting</div>
      </div>
    </div>

    <div class="typing-indicator" id="typingIndicator"></div>

    <div class="input-area" id="inputArea" style="display:none">
      <div class="input-wrap">
        <textarea id="chatInput" placeholder="Message..." rows="1" autocomplete="off"></textarea>
        <button class="send-btn" id="sendBtn" onclick="sendMessage()" disabled>‚Üë</button>
      </div>
    </div>
  </div>
</div>

<script>
// ‚ïê‚ïê‚ïê State ‚ïê‚ïê‚ïê
let GW_URL = '';
let GW_TOKEN = '';
let gwAgents = []; // [{id, displayName, emoji, model, ...}]
let currentChat = null; // agentId or 'general'
let chatHistories = {}; // { agentId: [{role,name,emoji,text,time}] }
let streamingAbort = null;
let isStreaming = false;

// ‚ïê‚ïê‚ïê Persistence ‚ïê‚ïê‚ïê
function saveConnection() {
  localStorage.setItem('hc-gw', JSON.stringify({ url: GW_URL, token: GW_TOKEN }));
}
function loadConnection() {
  try { const d = JSON.parse(localStorage.getItem('hc-gw')); return d; } catch { return null; }
}
function saveChats() {
  localStorage.setItem('hc-chats', JSON.stringify(chatHistories));
}
function loadChats() {
  try { chatHistories = JSON.parse(localStorage.getItem('hc-chats') || '{}'); } catch {}
}

// ‚ïê‚ïê‚ïê Init ‚ïê‚ïê‚ïê
function init() {
  loadChats();
  setupInput();

  // If served from the arena server, auto-connect (server has the token)
  if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
    GW_URL = `http://localhost:18789`;
    GW_TOKEN = '';
    tryAutoConnect();
    return;
  }

  const saved = loadConnection();
  if (saved && saved.url && saved.token) {
    GW_URL = saved.url;
    GW_TOKEN = saved.token;
    tryConnect();
  }
}

async function tryAutoConnect() {
  try {
    const res = await fetch('/api/gateway/test', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({}), // server uses its own token
      signal: AbortSignal.timeout(10000)
    });
    if (res.ok) {
      gwAgents = [
        { id: 'main', emoji: 'ü¶û' },
        { id: 'creator', emoji: 'üìà' },
        { id: 'founder', emoji: 'üî•' },
        { id: 'devops', emoji: 'üîí' },
        { id: 'sales', emoji: 'üí∞' }
      ];
      showApp();
      return;
    }
  } catch {}
  // Fall back to manual connect
}

// ‚ïê‚ïê‚ïê Connect ‚ïê‚ïê‚ïê
async function doConnect() {
  const url = document.getElementById('gwUrl').value.trim().replace(/\/+$/, '');
  const token = document.getElementById('gwToken').value.trim();
  const err = document.getElementById('connectError');
  const btn = document.getElementById('connectBtn');

  if (!url) { err.textContent = 'Enter your gateway URL'; return; }
  if (!token) { err.textContent = 'Enter your gateway token'; return; }

  err.textContent = '';
  btn.disabled = true;
  btn.textContent = 'Connecting...';

  GW_URL = url;
  GW_TOKEN = token;

  try {
    await fetchAgents();
    saveConnection();
    showApp();
  } catch (e) {
    err.textContent = e.message || 'Failed to connect';
    btn.disabled = false;
    btn.textContent = 'Connect ‚Üí';
  }
}

async function tryConnect() {
  try {
    await fetchAgents();
    showApp();
  } catch {
    // Show connect screen
    document.getElementById('gwUrl').value = GW_URL;
    document.getElementById('gwToken').value = GW_TOKEN;
  }
}

async function fetchAgents() {
  // Verify connection via our server proxy (avoids CORS)
  const res = await fetch('/api/gateway/test', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ gwUrl: GW_URL, gwToken: GW_TOKEN }),
    signal: AbortSignal.timeout(15000)
  });
  if (!res.ok) {
    const err = await res.json().catch(() => ({}));
    throw new Error(err.error || `Connection failed (${res.status})`);
  }

  // Connection verified! Load agent list from localStorage or use defaults
  const savedAgents = loadAgentList();
  if (savedAgents && savedAgents.length > 0) {
    gwAgents = savedAgents;
  } else {
    // Default agent list ‚Äî users can customize
    gwAgents = [
      { id: 'main', emoji: 'ü¶û' },
      { id: 'creator', emoji: 'üìà' },
      { id: 'founder', emoji: 'üî•' },
      { id: 'devops', emoji: 'üîí' },
      { id: 'sales', emoji: 'üí∞' }
    ];
    saveAgentList();
  }
}

function loadAgentList() {
  try { return JSON.parse(localStorage.getItem('hc-agents')); } catch { return null; }
}
function saveAgentList() {
  localStorage.setItem('hc-agents', JSON.stringify(gwAgents));
}

function getAgentEmoji(id) {
  const map = { main: 'ü¶û', creator: 'üìà', founder: 'üî•', devops: 'üîí', sales: 'üí∞' };
  return map[id] || 'ü§ñ';
}

function getAgentName(id) {
  const map = { main: 'Hopper', creator: 'Growth', founder: 'Forge', devops: 'DevOps', sales: 'Sales' };
  return map[id] || id;
}

function showApp() {
  document.getElementById('connectScreen').style.display = 'none';
  document.getElementById('chatApp').style.display = 'flex';
  document.getElementById('footerUrl').textContent = GW_URL.replace(/^https?:\/\//, '');
  setStatus('connected');
  renderSidebar();
}

function disconnect() {
  localStorage.removeItem('hc-gw');
  GW_URL = '';
  GW_TOKEN = '';
  gwAgents = [];
  currentChat = null;
  document.getElementById('chatApp').style.display = 'none';
  document.getElementById('connectScreen').style.display = 'flex';
  document.getElementById('connectError').textContent = '';
  document.getElementById('connectBtn').disabled = false;
  document.getElementById('connectBtn').textContent = 'Connect ‚Üí';
}

function setStatus(s) {
  const dot = document.getElementById('statusDot');
  dot.className = 'dot' + (s === 'connected' ? '' : s === 'connecting' ? ' connecting' : ' off');
}

// ‚ïê‚ïê‚ïê Sidebar ‚ïê‚ïê‚ïê
function renderSidebar() {
  const nav = document.getElementById('sidebarNav');
  let html = '';

  // Agents section
  html += '<div class="nav-group"><div class="nav-group-title">Your Agents</div>';
  for (const a of gwAgents) {
    const isActive = currentChat === a.id;
    const unread = getUnread(a.id);
    html += `<div class="nav-item${isActive ? ' active' : ''}" onclick="openChat('${a.id}')">
      <span class="ni-dot online"></span>
      <span class="ni-icon">${a.emoji}</span>
      <span class="ni-label">${esc(getAgentName(a.id))}</span>
      ${unread > 0 ? `<span class="ni-badge">${unread}</span>` : ''}
    </div>`;
  }
  html += '</div>';

  nav.innerHTML = html;
}

// ‚ïê‚ïê‚ïê Chat ‚ïê‚ïê‚ïê
function openChat(agentId) {
  currentChat = agentId;
  const agent = gwAgents.find(a => a.id === agentId);

  // Update header
  document.getElementById('headerEmoji').textContent = agent?.emoji || 'ü§ñ';
  document.getElementById('headerName').textContent = getAgentName(agentId);
  document.getElementById('headerSub').textContent = `Agent ‚Ä¢ ${agentId}`;

  // Show input
  document.getElementById('inputArea').style.display = '';
  document.getElementById('chatInput').placeholder = `Message ${getAgentName(agentId)}...`;

  // Clear unread
  clearUnread(agentId);

  // Render messages
  renderMessages();
  renderSidebar();
  closeSidebar();

  // Focus input on desktop
  if (window.innerWidth > 768) {
    document.getElementById('chatInput').focus();
  }
}

function renderMessages() {
  const area = document.getElementById('messages');
  const msgs = chatHistories[currentChat] || [];

  if (msgs.length === 0) {
    const agent = gwAgents.find(a => a.id === currentChat);
    area.innerHTML = `<div class="empty-state">
      <div class="es-emoji">${agent?.emoji || 'üí¨'}</div>
      <div class="es-title">Chat with ${esc(getAgentName(currentChat))}</div>
      <div class="es-sub">This agent has full tool access, persistent memory, and can collaborate with other agents in your workspace.</div>
    </div>`;
    return;
  }

  let html = '<div class="spacer"></div>';
  for (const m of msgs) {
    if (m.system) {
      html += `<div class="msg-system">${esc(m.text)}</div>`;
    } else {
      const nameColor = m.role === 'user' ? 'var(--accent2)' : 'var(--green)';
      html += `<div class="msg">
        <div class="m-avatar">${m.emoji || (m.role === 'user' ? 'üë§' : 'ü§ñ')}</div>
        <div class="m-body">
          <div class="m-head">
            <span class="m-name" style="color:${nameColor}">${esc(m.name || (m.role === 'user' ? 'You' : getAgentName(currentChat)))}</span>
            <span class="m-time">${m.time || ''}</span>
          </div>
          <div class="m-text">${renderMd(m.text)}</div>
        </div>
      </div>`;
    }
  }

  area.innerHTML = html;
  area.scrollTop = area.scrollHeight;
}

// ‚ïê‚ïê‚ïê Send & Stream ‚ïê‚ïê‚ïê
async function sendMessage() {
  const input = document.getElementById('chatInput');
  const text = input.value.trim();
  if (!text || !currentChat || isStreaming) return;

  input.value = '';
  input.style.height = 'auto';
  document.getElementById('sendBtn').disabled = true;

  const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  addMsg(currentChat, { role: 'user', text, time: now, emoji: 'üë§', name: 'You' });
  renderMessages();

  // Build messages array for API
  const history = (chatHistories[currentChat] || [])
    .filter(m => !m.system)
    .slice(-20) // last 20 messages for context
    .map(m => ({ role: m.role === 'user' ? 'user' : 'assistant', content: m.text }));

  isStreaming = true;
  const agent = gwAgents.find(a => a.id === currentChat);
  showTyping(getAgentName(currentChat));

  try {
    const controller = new AbortController();
    streamingAbort = controller;

    const res = await fetch('/api/gateway/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        agentId: currentChat,
        model: `openclaw:${currentChat}`,
        messages: history,
        stream: true,
        user: `huddleclaw-${currentChat}`
      }),
      signal: controller.signal
    });

    if (!res.ok) {
      const errText = await res.text();
      throw new Error(`API error ${res.status}: ${errText.slice(0, 200)}`);
    }

    // Stream SSE
    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let fullText = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        const data = line.slice(6).trim();
        if (data === '[DONE]') continue;

        try {
          const chunk = JSON.parse(data);
          const delta = chunk.choices?.[0]?.delta?.content;
          if (delta) {
            fullText += delta;
            // Live update the message
            updateStreamingMsg(currentChat, fullText, agent?.emoji);
          }
        } catch {}
      }
    }

    // Finalize
    hideTyping();
    if (fullText) {
      // Replace streaming message with final
      finalizeStreamingMsg(currentChat, fullText, agent?.emoji);
    }
  } catch (e) {
    hideTyping();
    if (e.name !== 'AbortError') {
      addMsg(currentChat, { system: true, text: `Error: ${e.message}` });
      renderMessages();
    }
  } finally {
    isStreaming = false;
    streamingAbort = null;
    document.getElementById('sendBtn').disabled = false;
    document.getElementById('chatInput').focus();
  }
}

function updateStreamingMsg(agentId, text, emoji) {
  if (currentChat !== agentId) return;
  const area = document.getElementById('messages');
  let streamEl = document.getElementById('streaming-msg');

  if (!streamEl) {
    const div = document.createElement('div');
    div.className = 'msg';
    div.id = 'streaming-msg';
    div.innerHTML = `<div class="m-avatar">${emoji || 'ü§ñ'}</div>
      <div class="m-body">
        <div class="m-head">
          <span class="m-name" style="color:var(--green)">${esc(getAgentName(agentId))}</span>
          <span class="m-time">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
        </div>
        <div class="m-text" id="streaming-text"></div>
      </div>`;
    area.appendChild(div);
    streamEl = div;
  }

  document.getElementById('streaming-text').innerHTML = renderMd(text);
  area.scrollTop = area.scrollHeight;
}

function finalizeStreamingMsg(agentId, text, emoji) {
  const streamEl = document.getElementById('streaming-msg');
  if (streamEl) streamEl.remove();

  const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  addMsg(agentId, { role: 'assistant', text, time: now, emoji: emoji || 'ü§ñ', name: getAgentName(agentId) });
  renderMessages();
}

// ‚ïê‚ïê‚ïê Message Storage ‚ïê‚ïê‚ïê
function addMsg(agentId, msg) {
  if (!chatHistories[agentId]) chatHistories[agentId] = [];
  chatHistories[agentId].push(msg);
  // Keep last 200 messages per chat
  if (chatHistories[agentId].length > 200) chatHistories[agentId] = chatHistories[agentId].slice(-200);
  saveChats();
}

// Unread tracking
const unreadCounts = {};
function getUnread(id) { return unreadCounts[id] || 0; }
function clearUnread(id) { delete unreadCounts[id]; }

// ‚ïê‚ïê‚ïê UI Helpers ‚ïê‚ïê‚ïê
function showTyping(name) {
  document.getElementById('typingIndicator').textContent = `${name} is thinking...`;
}
function hideTyping() {
  document.getElementById('typingIndicator').textContent = '';
}

function openSidebar() {
  document.getElementById('sidebar').classList.add('open');
  document.getElementById('backdrop').classList.add('show');
}
function closeSidebar() {
  document.getElementById('sidebar').classList.remove('open');
  document.getElementById('backdrop').classList.remove('show');
}

function setupInput() {
  const input = document.getElementById('chatInput');
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
  });
  input.addEventListener('input', () => {
    input.style.height = 'auto';
    input.style.height = Math.min(input.scrollHeight, 120) + 'px';
    document.getElementById('sendBtn').disabled = !input.value.trim();
  });
}

// ‚ïê‚ïê‚ïê Markdown ‚ïê‚ïê‚ïê
function renderMd(text) {
  if (!text) return '';
  let html = esc(text);
  // Code blocks
  html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) =>
    `<pre><code>${code.trim()}</code></pre>`
  );
  // Inline code
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
  // Bold
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  // Italic
  html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
  // Headers
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
  // Lists
  html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
  // Blockquote
  html = html.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');
  // Links
  html = html.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener">$1</a>');
  // Line breaks (but not inside pre/code)
  html = html.replace(/\n/g, '<br>');
  return html;
}

function esc(t) { const d = document.createElement('div'); d.textContent = t || ''; return d.innerHTML; }

// ‚ïê‚ïê‚ïê Go ‚ïê‚ïê‚ïê
init();
</script>
</body>
</html>
